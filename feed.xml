<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://bmin.ai/feed.xml" rel="self" type="application/atom+xml" /><link href="https://bmin.ai/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-05-03T08:57:52+00:00</updated><id>https://bmin.ai/feed.xml</id><title type="html">bmin.ai</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design.
</subtitle><entry><title type="html">Sentence Segmentation and Why It Matters</title><link href="https://bmin.ai/blog/2021/sentence/" rel="alternate" type="text/html" title="Sentence Segmentation and Why It Matters" /><published>2021-05-22T00:00:00+00:00</published><updated>2021-05-22T00:00:00+00:00</updated><id>https://bmin.ai/blog/2021/sentence</id><content type="html" xml:base="https://bmin.ai/blog/2021/sentence/"><![CDATA[<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

<script src="https://cdn.quilljs.com/1.3.7/quill.min.js"></script>

<script>
    const Inline = Quill.import("blots/inline");

    function createBlot(name, extraClass) {
        class SplitBlot extends Inline {
            static blotName = name;
            static tagName = "span";
            constructor(domNode, value) {
                super(domNode, value);
                if (typeof value === "object") {
                    this.domNode.dataset.guid = value.guid;
                }
            }

            static create() {
                const node = super.create();
                node.classList.add("split");
                if (extraClass) {
                    node.classList.add(extraClass);
                }
                return node;
            }

            static formats(node) {
                return node.dataset.guid;
            }
        }
        Quill.register(SplitBlot);

        // see https://github.com/quilljs/quill/issues/2312#issuecomment-426221880
        Inline.order.splice(Inline.order.indexOf("bold"), 0, name);
    }
    createBlot("split");
    createBlot("split-ud", "split-ud");
    createBlot("split-opus100", "split-opus100");
    createBlot("split-ersatz", "split-ersatz");

    async function getEmbeddings(url) {
        return await fetch(url).then((response) => {
            return response.arrayBuffer();
        }).then((buffer) => {
            let view = new DataView(buffer);
            let numBuckets = view.getInt32(0, true);
            let numHashes = view.getInt32(4, true);
            let hashDim = (view.byteLength - 8) / (numBuckets * numHashes) / 4;

            let embeddings = [...Array(numHashes)].map(() => []);
            for (let i = 0; i < numBuckets; i++) {
                for (let j = 0; j < numHashes; j++) {
                    let offset = 8 + (i * numHashes + j) * hashDim * 4;
                    let data = new Float32Array(buffer, offset, hashDim);
                    embeddings[j].push(data);
                }
            }

            return embeddings;
        });
    }

    async function getClf(url) {
        return await fetch(url).then((response) => {
            return response.arrayBuffer();
        }).then((buffer) => {
            let view = new DataView(buffer);
            let nCoefs = buffer.byteLength / 8 - 2;
            let intercept = view.getFloat64(0, true);
            let threshold = view.getFloat64((nCoefs + 1) * 8, true);

            let coefs = [];

            for (let i = 0; i < nCoefs; i++) {
                let coef = view.getFloat64((i + 1) * 8, true);
                coefs.push(coef);
            }

            return {
                coefs: coefs,
                intercept: intercept,
                threshold: threshold
            };
        });
    }

    async function getModel() {
        const [embeddings, session, udClf, opus100Clf, ersatzClf] = await Promise.all([
            getEmbeddings("/assets/blog/sentence/embeddings.bin"),
            ort.InferenceSession.create('/assets/blog/sentence/model.onnx'),
            getClf("/assets/blog/sentence/en_ud_embeddings.bin"),
            getClf("/assets/blog/sentence/en_opus100_embeddings.bin"),
            getClf("/assets/blog/sentence/en_ersatz_embeddings.bin"),
        ]);

        return {
            embeddings: embeddings,
            session: session,
            udClf: udClf,
            opus100Clf: opus100Clf,
            ersatzClf: ersatzClf
        };
    }

    const model = getModel();

    // use an async context to call onnxruntime functions.

    const _PRIMES = [31, 43, 59, 61, 73, 97, 103, 113, 137, 149, 157, 173, 181, 193, 211, 223];

    function embed(text, embeddings) {
        let numBuckets = embeddings[0].length;
        let numHashes = embeddings.length;
        let hashDim = embeddings[0][0].length;

        let result = new Float32Array(text.length * numHashes * hashDim);
        for (let i = 0; i < text.length; i++) {
            for (let j = 0; j < numHashes; j++) {
                let hash = ((text.charCodeAt(i) + 1) * _PRIMES[j]) % numBuckets;

                for (let k = 0; k < hashDim; k++) {
                    result[i * numHashes * hashDim + j * hashDim + k] = embeddings[j][hash][k];
                }
            }
        }

        return {
            data: result,
            dim: numHashes * hashDim
        };
    }

    function sigmoid(x) {
        return 1 / (1 + Math.exp(-x));
    }

    async function infer(text, model, selectedStyle) {
        const emb = embed(text, (await model).embeddings);
        const tensorInputsEmbeds = new ort.Tensor('float32', emb.data, [1, text.length, emb.dim]);

        // prepare feeds. use model input names as keys.
        const feeds = { inputs_embeds: tensorInputsEmbeds };

        // feed inputs and run
        const results = await (await model).session.run(feeds);

        // read from results
        const logits = results.logits.data;
        const dim = results.logits.dims[results.logits.dims.length - 1];
        const newlineProbs = new Float32Array(text.length);
        const udProbs = new Float32Array(text.length);
        const opus100Probs = new Float32Array(text.length);
        const ersatzProbs = new Float32Array(text.length);

        for (let i = 0; i < text.length; i++) {
            newlineProbs[i] = sigmoid(logits[dim * i]);
            udProbs[i] = (await model).udClf.intercept;
            for (let j = 0; j < dim; j++) {
                udProbs[i] += logits[dim * i + j] * (await model).udClf.coefs[j];
            }

            udProbs[i] = sigmoid(udProbs[i]);

            opus100Probs[i] = (await model).opus100Clf.intercept;
            for (let j = 0; j < dim; j++) {
                opus100Probs[i] += logits[dim * i + j] * (await model).opus100Clf.coefs[j];
            }
            opus100Probs[i] = sigmoid(opus100Probs[i]);

            ersatzProbs[i] = (await model).ersatzClf.intercept;
            for (let j = 0; j < dim; j++) {
                ersatzProbs[i] += logits[dim * i + j] * (await model).ersatzClf.coefs[j];
            }
            ersatzProbs[i] = sigmoid(ersatzProbs[i]);
        }

        if (selectedStyle == "ud") {
            return {
                probs: udProbs,
                threshold: (await model).udClf.threshold
            };
        } else if (selectedStyle == "opus100") {
            return {
                probs: opus100Probs,
                threshold: (await model).opus100Clf.threshold
            };
        } else if (selectedStyle == "ersatz") {
            return {
                probs: ersatzProbs,
                threshold: (await model).ersatzClf.threshold
            };
        } else {
            return {
                probs: newlineProbs,
                threshold: 0.01
            };
        }
    }

    function registerDemo(name, options) {
        let selectedStyle = null;

        window.addEventListener("load", () => {
            const quill = new Quill(name + "-quill", {
                modules: {
                    toolbar: null,
                    history: {
                        userOnly: true,
                    },
                },
                formats: ["split", "split-ud", "split-opus100", "split-ersatz"],
            });
            quill.root.setAttribute("spellcheck", false);
            
            // see https://github.com/quilljs/quill/issues/110#issuecomment-461591218
            delete quill.getModule("keyboard").bindings["9"];

            function getText() {
                return Array.from(quill.container.querySelectorAll("p"))
                    .map((el) => el.textContent)
                    .join("\n");
            }

            let predict_timeout = null;
            let predict_delta = 300;

            async function populate(text) {
                const inference = await infer(text, model, selectedStyle);
                const probs = inference.probs;
                const threshold = inference.threshold;

                if (getText() != text) {
                    // split is not valid anymore
                    return;
                }

                quill.formatText(0, text.length, { split: false, ["split-ud"]: false, ["split-opus100"]: false, ["split-ersatz"]: false });

                let offset = 0;
                probs[text.length - 1] = 1.0;
                for (let i = 0; i < text.length; i++) {
                    if (probs[i] > threshold) {
                        let length = i - offset + 1;
                        let blotName = "split";
                        if (selectedStyle == "ud") {
                            blotName = "split-ud";
                        } else if (selectedStyle == "opus100") {
                            blotName = "split-opus100";
                        } else if (selectedStyle == "ersatz") {
                            blotName = "split-ersatz";
                        }

                        quill.formatText(offset, length, {
                            [blotName]: {
                                guid: `${offset}_${length}`,
                            },
                        });
                        offset = i + 1;
                    }
                }
            }

            quill.on("text-change", async (delta, oldDelta, user) => {
                let text = getText();

                document.querySelector(name + " .clear-button").disabled = text == "";
                document.querySelector(name + " .example-button").disabled = text == options.exampleText;

                if (user === "api") {
                    return;
                }

                quill.formatText(0, text.length, { split: false });

                clearTimeout(predict_timeout);
                predict_timeout = setTimeout(() => {
                    populate(text);
                }, predict_delta);
            });

            document.querySelector(name + " .example-button").addEventListener("click", () => {
                quill.setText(options.exampleText, "api");
                setTimeout(() => {
                    populate(options.exampleText);
                });
                userEditing = false;
            });
            document.querySelector(name + " .clear-button").addEventListener("click", () => {
                quill.setText("", "user");
                userEditing = false;
            });

            if (options.enablePunct) {
                selectedStyle = "ud";
                function styleStyle() {
                    document.querySelector(name + " .ud-button").classList.remove("selected-button");
                    document.querySelector(name + " .opus100-button").classList.remove("selected-button");
                    document.querySelector(name + " .ersatz-button").classList.remove("selected-button");
                
                    if (selectedStyle == "ud") {
                        document.querySelector(name + " .ud-button").classList.add("selected-button");
                    }
                    if (selectedStyle == "opus100") {
                        document.querySelector(name + " .opus100-button").classList.add("selected-button");
                    }
                    if (selectedStyle == "ersatz") {
                        document.querySelector(name + " .ersatz-button").classList.add("selected-button");
                    }
                }
                styleStyle();
                document.querySelector(name + " .ud-button").addEventListener("click", () => {
                    selectedStyle = "ud";
                    styleStyle();
                    setTimeout(() => {
                        populate(getText());
                    });
                });
                document.querySelector(name + " .opus100-button").addEventListener("click", () => {
                    selectedStyle = "opus100";
                    styleStyle();
                    setTimeout(() => {
                        populate(getText());
                    });
                });
                document.querySelector(name + " .ersatz-button").addEventListener("click", () => {
                    selectedStyle = "ersatz";
                    styleStyle();
                    setTimeout(() => {
                        populate(getText());
                    });
                });
            }

            quill.setText(options.exampleText, "api");
            populate(options.exampleText);
        });   
    }
</script>

<style>
    .editor-container {
        border: 1px solid rgba(0, 0, 0, 0.2);
        border-radius: 5px;
    }

    .punct-line {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.5rem;
    }

    .tool-line {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.5rem;
        margin-bottom: 2rem;
    }

    .distill-button {
        background-color: var(--global-button-color);
        border-radius: 8px;
        border-width: 0;
        cursor: pointer;
        display: inline-block;
        font-size: 14px;
        font-weight: 500;
        line-height: 20px;
        list-style: none;
        margin: 0;
        padding: 10px 12px;
        text-align: center;
        margin: 0 0.2rem;
    }

    .distill-button:disabled {
        opacity: 0.8;
    }
    
    .tool-line .distill-button:hover {
        background-color: var(--global-button-color-hover);
    }

    .punct-line .distill-button {
        opacity: 0.4;
        color: white;
    }

    .punct-line .distill-button:hover {
        opacity: 1;
    }

    .ud-button {
        background-color: var(--green-color);
    }

    .opus100-button {
        background-color: var(--red-color);
    }

    .ersatz-button {
        background-color: var(--blue-color);
    }

    .punct-line .selected-button {
        opacity: 1;
    }

    .model {
        position: relative;
        display: inline-block;
    }

    .model-identifier {
        font-family: monospace;
        color: var(--global-theme-color);
    }

    .split::after {
        position: absolute;
        content: "";
        width: 3px;
        height: 1.3rem;
        background-color: var(--global-theme-color);
    }

    .split.split-ud::after {
        background-color: var(--green-color);
    }

    .split.split-opus100::after {
        background-color: var(--red-color);
    }

    .split.split-ersatz::after {
        background-color: var(--blue-color);
    }

    .split:last-child::after {
        width: 0px;
    }

    .editor-container .ql-editor {
        padding: 1rem 0.5rem;        
        height: auto;
        min-height: 250px;
    }

    .editor-container .ql-editor p {
        font-family: "Roboto", sans-serif;
        font-size: 16.96px;
    }

    .editor-container .ql-editor p::after {
        position: absolute;
        width: 2px;
        height: 1.3rem;
        color:rgba(0, 0, 0, 0.2);
    }

    .editor-container .ql-container {
        height: auto;
    }

    .editor-container #quill-editor {
        height: 250px;
        overflow-y: scroll;
    }
</style>

<link href="//cdn.quilljs.com/1.0.0/quill.snow.css" rel="stylesheet" />

<div id="main-demo" aria-hidden="true">
    <div class="editor-container">
        <p id="main-demo-quill"></p>
    </div>
    <div class="tool-line">
        <div class="model mr-auto">Model: <span class="model-identifier">wtp-bert-tiny</span></div>
        <button class="example-button distill-button">Example Text</button>
        <button class="clear-button distill-button">Clear</button>
    </div>
</div>

<script>
    registerDemo("#main-demo", {
        exampleText: "Click here to play around with sentence segmentation! The best segmentation is often obvious, but in some cases it's not. For example, when they said \"This is a sentence. This is another sentence\", it is not obvious whether the quote should be part of the surrounding sentence, or should itself be split into sentences.\n\nThe model is loaded on the client-side in your browser. It is fast enough to allow live-editing. Check out the Github repository to use it yourself: github.com/bminixhofer/wtpsplit."
    });
</script>

<p><span id="introduction" style="padding-top: 4.8rem;">Sentences are fundamental to written language.</span> Naturally, Natural Language Processing often involves sentences. For example, the original BERT did Next <em>Sentence</em> Prediction, creation of the C4 corpus involved removing “any page with fewer than 5 <em>sentences</em>” and datasets such as MultiNLI consist of annotated <em>sentence</em> pairs. In fact, around 72% of the papers in the ACL Anthology contain the word “sentence” (~16% in the abstract). However, many of these say do not say what they mean by “sentence”. As usual, BERT is a standout by containing the following admission:</p>

<blockquote>
  <p>Throughout this work, a “sentence” can be an arbitrary span of contiguous text, rather than an actual linguistic sentence.</p>
</blockquote>

<p>Why do the authors concede all linguistic meaning of a sentence? And what do others mean when they say “sentence”? Like all things involving natural language, it’s complicated. Attempts to define sentences go back at least 130 years to Henry Sweet’s now-copied-all-over-textbooks definition<d-cite key="sweet2014new"></d-cite>:</p>

<blockquote>
  <p>A sentence is a word or group of words capable of expressing a complete thought or meaning.</p>
</blockquote>

<p>This definition is not really workable. It moves the problem to another term — what is a complete thought? There are chunks of text which most people would probably agree make up a sentence, but hardly convey a complete thought.<d-footnote>For example "Look, having nuclear — my uncle was a great professor and scientist and engineer, Dr. John Trump at MIT; good genes, very good genes, OK, very smart, the Wharton School of Finance, very good, very smart — you know, if you’re a conservative Republican, if I were a liberal, if, like, OK, if I ran as a liberal Democrat, they would say I'm one of the smartest people anywhere in the world — it’s true! — but when you're a conservative Republican they try — oh, do they do a number — that’s why I always start off: Went to Wharton, was a good student, went there, went there, did this, built a fortune — you know I have to give my like credentials all the time, because we’re a little disadvantaged — but you look at the nuclear deal, the thing that really bothers me — it would have been so easy, and it’s not as important as these lives are — nuclear is so powerful; my uncle explained that to me many, many years ago, the power and that was 35 years ago; he would explain the power of what's going to happen and he was right, who would have thought? — but when you look at what's going on with the four prisoners — now it used to be three, now it’s four — but when it was three and even now, I would have said it's all in the messenger; fellas, and it is fellas because, you know, they don't, they haven’t figured that the women are smarter right now than the men, so, you know, it’s gonna take them about another 150 years — but the Persians are great negotiators, the Iranians are great negotiators, so, and they, they just killed, they just killed us, this is horrible." via <a href="https://www.snopes.com/fact-check/donald-trump-sentence">https://www.snopes.com/fact-check/donald-trump-sentence.</a></d-footnote> As such, when someone refers to “sentences” in NLP, they usually mean one of two things:</p>

<ol>
  <li>A chunk of text that resulted from instructing annotators to create a sentence, or to segment an existing text into sentences (“ground-truth sentences”).</li>
  <li>Predicted sentences from an automatic sentence segmentation tool, such as Punkt. Many of these are trained on ground-truth sentences.</li>
</ol>

<p>The MultiNLI corpus is a collection of the first type. The filtering in the C4 corpus is an example of the second: it wouldn’t be feasible to manually segment a large portion of the web into sentences.</p>

<p>At first glance, it seems like we’re good. If it’s feasible, use ground-truth sentences created by human annotators. If not, approximate the ground-truth with an automatic sentence segmentation tool. But there are some problems.</p>

<p><strong>“Ground-truth” sentence boundaries are not objectively true.</strong></p>

<p>Many things involving language are subjective. It might seem like something as fundamental as sentence segmentation could  at least be solved objectively, but alas! There is plenty of room for interpretation in what to consider one sentence. Does nesting via quotation marks constitute a sentence boundary? What about parentheses, enumerations, colons, and semicolons? Different collections of sentences will have different styles of segmentation. <d-footnote>Style can also vary within a collection via different annotators or inconsistencies of an individual annotator.</d-footnote> For example, sentences in the UD, OPUS100 and Ersatz collections look noticeably different from each other.</p>

<div id="styles-demo" aria-hidden="true">
    <div class="punct-line">
        <span class="ml-auto">Style: </span>
        <button class="ud-button distill-button">UD</button>
        <button class="opus100-button distill-button">OPUS100</button>
        <button class="ersatz-button distill-button">Ersatz</button>
    </div>
    <div class="editor-container">
        <p id="styles-demo-quill"></p>
    </div>
    <div class="tool-line">
        <div class="model mr-auto">Model: <span class="model-identifier">wtp-bert-tiny</span></div>
        <button class="example-button distill-button">Example Text</button>
        <button class="clear-button distill-button">Clear</button>
    </div>
    <p class="caption">Try out how the same piece of text may be segmented in different collections.</p>
</div>

<script>
    registerDemo("#styles-demo", {
        enablePunct: true,
        exampleText: "This is the high season for tourism; between December and April few people visit and many tour companies and restaurants close down.\n\n’I couldn’t help it,’ said Five, in a sulky tone; ’Seven jogged my elbow.’ On which Seven looked up and said, ’That’s right, Five! Always lay the blame on others.’\n\n\"A lot of people would like to go back to 1970,\" before program trading, he said. \"I would like to go back to 1970. But we’re not going back to 1970.\""
    });
</script>

<style>
    #styles-demo {
        position: relative;
        margin-bottom: 2rem;
    }

    @media (min-width: 992px) {
        #styles-demo .caption {
            position: absolute;
            top: 8rem;
            left: calc(100% + 1rem);
            text-align: left !important;
            width: 8.5rem;
        }
    }

    #styles-demo .caption {
        text-align: center;
        line-height: 1.2rem;
        opacity: 0.7;
    }
</style>

<p><strong>It’s hard to acquire ground-truth sentences for low-resource languages.</strong></p>

<p>Like any kind of labelled data, it’s hard to get ground-truth sentences for the long tail of low-resource languages. This makes it hard to create sentence segmentation tools for these languages.</p>

<p><strong>Existing sentence segmentation tools rely on punctuation.</strong></p>

<p>Existing sentence segmentation tools like Ersatz and Punkt rely on punctuation by treating sentence segmentation as a <em>disambiguation</em> task. They look at all punctuation characters in the text, and for each one, decide whether it constitutes a sentence boundary or not. This is a reasonable approach, but it falls apart in some cases. If a text is missing punctuation, it can not be segmented. Also, text in languages which do not use punctuation (most prominently Thai) can not be segmented.</p>

<blockquote>
  <p>English: Many sentence segmentation tools rely on punctuation. That can be a problem in Thai.</p>

  <p>Thai: เครื่องมือแบ่งส่วนประโยคจำนวนมากใช้เครื่องหมายวรรคตอน นั่นอาจเป็นปัญหาในภาษาไทย</p>

</blockquote>

<p>We tried to solve these issues by creating a <em>punctuation-agnostic</em>, <em>adaptible</em> sentence segmentation tool which can be trained without any ground-truth sentences via self-supervision.</p>

<h2 id="self-supervised-sentence-segmentation">Self-Supervised Sentence Segmentation</h2>

<p>Our key insight is that a model which is good at predicting the probability for a <strong>new line (\n)</strong> to occur after any character can segment text into sentences. This could be a decoder-style model à la GPT trained on next-character prediction. We use an encoder-style model trained with a newline-corruption method instead to use context from both sides of every character. Like pretraining GPT models, this does not require any labelled data; it’s just language modelling.</p>

<p>The model learns how likely it is for any character to be followed by a new line. The predicted <em>newline probability</em> characterizes sentence boundaries: a new line can never occur within a sentence, while at the same time, a new line can generally occur after any sentence. This allows us to define sentences in a much more concrete way.</p>

<blockquote>
  <p>Tired: A sentence is a word or group of words capable of expressing a complete thought or meaning.</p>

  <p>Wired: <strong style="color: var(--global-theme-color);">A sentence is any sequence of characters which could plausibly be followed by a newline.</strong></p>
</blockquote>

<p>Admittedly, the word “plausibly” still does a lot of heavy lifting here: we need a probability threshold to decide when to count a character as “plausibly followed by a newline”. However, this threshold can just be set to a small constant value like 1%, where different thresholds give rise to different sets of sentences.</p>

<div id="probabilities-demo" aria-hidden="true">
    <div class="editor-container">
        <p id="probabilities-demo-quill"></p>
    </div>
    <div class="tool-line">
        <div class="model mr-auto">Model: <span class="model-identifier">wtp-bert-tiny</span></div>
        <button class="example-button distill-button">Example Text</button>
        <button class="clear-button distill-button">Clear</button>
    </div>
</div>

<script>
    registerDemo("#probabilities-demo", {
        exampleText: "Click here to play around with sentence segmentation! The best segmentation is often obvious, but in some cases it's not. For example, when they said \"This is a sentence. This is another sentence\", it is not obvious whether the quote should be part of the surrounding sentence, or should itself be split into sentences.\n\nThe model is loaded on the client-side in your browser. It is fast enough to allow live-editing. Check out the Github repository to use it yourself: github.com/bminixhofer/wtpsplit.",
        useGradient: true
    });
</script>

<h2 id="where-s-the-point">Where's the Point?</h2>]]></content><author><name></name></author><summary type="html"><![CDATA[Accompanying the paper &quot;Where’s the Point? Self-Supervised Multilingual Punctuation-Agnostic Sentence Segmentation&quot; with Jonas Pfeiffer and Ivan Vulić, accepted at ACL 2023.]]></summary></entry></feed>