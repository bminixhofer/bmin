<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<script src="https://cdn.quilljs.com/1.3.7/quill.min.js"></script>
<script>
    const Inline = Quill.import("blots/inline");

    const CACHE_SIZE = 1000;
    const CACHE_QUEUE = [];
    const CACHE = {};

    class SplitBlot extends Inline {
        static blotName = "split";
        static tagName = "span";
        constructor(domNode, value) {
            super(domNode, value);
            if (typeof value === "object") {
                this.domNode.dataset.guid = value.guid;
                if (value.selectedStyle) {
                    this.domNode.dataset.style = value.selectedStyle;
                }
            }
        }

        static create() {
            const node = super.create();
            node.classList.add("split");
            return node;
        }

        static formats(node) {
            return node.dataset.guid;
        }
    }
    Quill.register(SplitBlot);

    // see https://github.com/quilljs/quill/issues/2312#issuecomment-426221880
    Inline.order.splice(Inline.order.indexOf("bold"), 0, name);

    async function getEmbeddings(url) {
        return await fetch(url).then((response) => {
            return response.arrayBuffer();
        }).then((buffer) => {
            let view = new DataView(buffer);
            let numBuckets = view.getInt32(0, true);
            let numHashes = view.getInt32(4, true);
            let hashDim = (view.byteLength - 8) / (numBuckets * numHashes) / 4;

            let embeddings = [...Array(numHashes)].map(() => []);
            for (let i = 0; i < numBuckets; i++) {
                for (let j = 0; j < numHashes; j++) {
                    let offset = 8 + (i * numHashes + j) * hashDim * 4;
                    let data = new Float32Array(buffer, offset, hashDim);
                    embeddings[j].push(data);
                }
            }

            return embeddings;
        });
    }

    async function getClf(url) {
        return await fetch(url).then((response) => {
            return response.arrayBuffer();
        }).then((buffer) => {
            let view = new DataView(buffer);
            let nCoefs = buffer.byteLength / 8 - 2;
            let intercept = view.getFloat64(0, true);
            let threshold = view.getFloat64((nCoefs + 1) * 8, true);

            let coefs = [];

            for (let i = 0; i < nCoefs; i++) {
                let coef = view.getFloat64((i + 1) * 8, true);
                coefs.push(coef);
            }

            return {
                coefs: coefs,
                intercept: intercept,
                threshold: threshold
            };
        });
    }

    async function getModel() {
        const [embeddings, session, udClf, opus100Clf, ersatzClf] = await Promise.all([
            getEmbeddings("/assets/blog/sentence/embeddings.bin"),
            ort.InferenceSession.create('/assets/blog/sentence/model.onnx'),
            getClf("/assets/blog/sentence/en_ud_embeddings.bin"),
            getClf("/assets/blog/sentence/en_opus100_embeddings.bin"),
            getClf("/assets/blog/sentence/en_ersatz_embeddings.bin"),
        ]);

        return {
            embeddings: embeddings,
            session: session,
            udClf: udClf,
            opus100Clf: opus100Clf,
            ersatzClf: ersatzClf
        };
    }

    const model = getModel();

    // use an async context to call onnxruntime functions.

    const _PRIMES = [31, 43, 59, 61, 73, 97, 103, 113, 137, 149, 157, 173, 181, 193, 211, 223];

    function embed(text, embeddings) {
        let numBuckets = embeddings[0].length;
        let numHashes = embeddings.length;
        let hashDim = embeddings[0][0].length;

        let result = new Float32Array(text.length * numHashes * hashDim);
        for (let i = 0; i < text.length; i++) {
            for (let j = 0; j < numHashes; j++) {
                let hash = ((text.charCodeAt(i) + 1) * _PRIMES[j]) % numBuckets;

                for (let k = 0; k < hashDim; k++) {
                    result[i * numHashes * hashDim + j * hashDim + k] = embeddings[j][hash][k];
                }
            }
        }

        return {
            data: result,
            dim: numHashes * hashDim
        };
    }

    function sigmoid(x) {
        return 1 / (1 + Math.exp(-x));
    }

    async function infer(text, model, selectedStyle) {
        let cacheKey = text + selectedStyle;

        if (CACHE[cacheKey]) {
            return CACHE[cacheKey];
        }
 
        let maxLength = 512;
        let stride = 256;
    
        const counts = new Int32Array(text.length);
        const newlineProbs = new Float32Array(text.length);
        const udProbs = new Float32Array(text.length);
        const opus100Probs = new Float32Array(text.length);
        const ersatzProbs = new Float32Array(text.length);
        
        let start = 0;
        let end = 0;
        while (end < text.length) {
            end = Math.min(start + maxLength, text.length);
            start = Math.max(0, end - maxLength);

            let sampleText = text.slice(start, end);

            const emb = embed(sampleText, (await model).embeddings);
            const tensorInputsEmbeds = new ort.Tensor('float32', emb.data, [1, sampleText.length, emb.dim]);

            // prepare feeds. use model input names as keys.
            const feeds = { inputs_embeds: tensorInputsEmbeds };

            // feed inputs and run
            const results = await (await model).session.run(feeds);

            // read from results
            const logits = results.logits.data;
            const dim = results.logits.dims[results.logits.dims.length - 1];

            for (let i = 0; i < sampleText.length; i++) {
                let globalI = start + i;

                newlineProbs[globalI] = sigmoid(logits[dim * i]);
                counts[globalI] += 1;

                udProbs[globalI] = (await model).udClf.intercept;
                for (let j = 0; j < dim; j++) {
                    udProbs[globalI] += logits[dim * i + j] * (await model).udClf.coefs[j];
                }

                udProbs[globalI] = sigmoid(udProbs[globalI]);

                opus100Probs[globalI] = (await model).opus100Clf.intercept;
                for (let j = 0; j < dim; j++) {
                    opus100Probs[i] += logits[dim * i + j] * (await model).opus100Clf.coefs[j];
                }
                opus100Probs[globalI] = sigmoid(opus100Probs[globalI]);

                ersatzProbs[globalI] = (await model).ersatzClf.intercept;
                for (let j = 0; j < dim; j++) {
                    ersatzProbs[globalI] += logits[dim * i + j] * (await model).ersatzClf.coefs[j];
                }
                ersatzProbs[globalI] = sigmoid(ersatzProbs[globalI]);
            }
            start += stride;
        }

        // normalize probs
        for (let i = 0; i < text.length; i++) {
            newlineProbs[i] /= counts[i];
            udProbs[i] /= counts[i];
            opus100Probs[i] /= counts[i];
            ersatzProbs[i] /= counts[i];
        }

        let out;

        if (selectedStyle == "ud") {
            out = {
                probs: udProbs,
                threshold: (await model).udClf.threshold
            };
        } else if (selectedStyle == "opus100") {
            out = {
                probs: opus100Probs,
                threshold: (await model).opus100Clf.threshold
            };
        } else if (selectedStyle == "ersatz") {
            out = {
                probs: ersatzProbs,
                threshold: (await model).ersatzClf.threshold
            };
        } else {
            out = {
                probs: newlineProbs,
                threshold: 0.01
            };
        }

        CACHE[cacheKey] = out;
        CACHE_QUEUE.push(cacheKey);

        if (CACHE_QUEUE.length > CACHE_SIZE) {
            delete CACHE[CACHE_QUEUE.shift()];
        }

        return out;
    }

    function registerDemo(name, options) {
        let selectedStyle = null;

        window.addEventListener("load", () => {
            const quill = new Quill(name + "-quill", {
                modules: {
                    toolbar: null,
                    history: {
                        userOnly: true,
                    },
                },
                formats: ["split"],
            });
            quill.root.setAttribute("spellcheck", false);
            
            // see https://github.com/quilljs/quill/issues/110#issuecomment-461591218
            delete quill.getModule("keyboard").bindings["9"];

            function getText() {
                return Array.from(quill.container.querySelectorAll("p"))
                    .map((el) => el.textContent)
                    .join("\n");
            }

            let predict_timeout = null;
            let predict_delta = 300;

            async function populate(text, thresholdOverride) {
                const inference = await infer(text, model, selectedStyle);
                const probs = inference.probs;
                const threshold = thresholdOverride != null ? thresholdOverride : inference.threshold;

                if (getText() != text) {
                    // split is not valid anymore
                    return;
                }

                quill.formatText(0, text.length, { split: false }, "api");

                let offset = 0;
                probs[text.length - 1] = 1.0;
                for (let i = 0; i < text.length; i++) {
                    if (probs[i] > threshold) {
                        let length = i - offset + 1;

                        quill.formatText(offset, length, {
                            "split": {
                                guid: `${offset}_${length}`,
                                selectedStyle: selectedStyle
                            },
                        }, "api");
                        offset = i + 1;
                    }
                }
            }

            quill.on("text-change", async (delta, oldDelta, user) => {
                let text = getText();

                document.querySelector(name + " .clear-button").disabled = text == "";
                document.querySelector(name + " .example-button").disabled = text == options.exampleText;

                if (user === "api") {
                    return;
                }

                quill.formatText(0, text.length, { split: false });

                clearTimeout(predict_timeout);
                predict_timeout = setTimeout(() => {
                    populate(text);
                }, predict_delta);
            });

            document.querySelector(name + " .example-button").addEventListener("click", () => {
                quill.setText(options.exampleText, "api");
                setTimeout(() => {
                    populate(options.exampleText);
                });
            });
            document.querySelector(name + " .clear-button").addEventListener("click", () => {
                quill.setText("", "user");
            });

            if (options.enableThreshold) {
                element = document.querySelector(name + " #newline-prob-threshold");

                function updateThreshold(element) {
                    let temperature = 9.787;
                    let range = Math.exp(temperature);
                    let minValue = Math.exp(0);
                    let value = (Math.exp(element.value / 100 * temperature) - minValue) / range;

                    setTimeout(() => {
                        document.querySelector(name + " #newline-prob-value").textContent = (value * 100).toFixed(3) + "%";
                        populate(getText(), value);
                    });
                }

                element.addEventListener("input", function() {
                    quill.blur();
                    updateThreshold(this);
                });
                updateThreshold(element);
            }

            if (options.enablePunct) {
                selectedStyle = "ud";
                function styleStyle() {
                    document.querySelector(name + " .ud-button").classList.remove("selected-button");
                    document.querySelector(name + " .opus100-button").classList.remove("selected-button");
                    document.querySelector(name + " .ersatz-button").classList.remove("selected-button");
                
                    if (selectedStyle == "ud") {
                        document.querySelector(name + " .ud-button").classList.add("selected-button");
                    }
                    if (selectedStyle == "opus100") {
                        document.querySelector(name + " .opus100-button").classList.add("selected-button");
                    }
                    if (selectedStyle == "ersatz") {
                        document.querySelector(name + " .ersatz-button").classList.add("selected-button");
                    }
                }
                styleStyle();
                document.querySelector(name + " .ud-button").addEventListener("click", () => {
                    selectedStyle = "ud";
                    styleStyle();
                    setTimeout(() => {
                        populate(getText());
                    });
                });
                document.querySelector(name + " .opus100-button").addEventListener("click", () => {
                    selectedStyle = "opus100";
                    styleStyle();
                    setTimeout(() => {
                        populate(getText());
                    });
                });
                document.querySelector(name + " .ersatz-button").addEventListener("click", () => {
                    selectedStyle = "ersatz";
                    styleStyle();
                    setTimeout(() => {
                        populate(getText());
                    });
                });
            }

            quill.setText(options.exampleText, "api");
            populate(options.exampleText);
        });
    }
</script>

<style>
    .caption {
        text-align: center;
        line-height: 1.2rem;
        color: var(--global-text-color-light) !important;
    }

    .editor-container {
        border: 1px solid rgba(0, 0, 0, 0.2);
        border-radius: 5px;
    }

    .punct-line {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.5rem;
    }

    .tool-line {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.5rem;
        margin-bottom: 1rem;
    }

    .threshold-line {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.5rem;
    }

    .distill-button {
        background-color: var(--global-button-color);
        color: var(--global-text-color);
        border-radius: 8px;
        border-width: 0;
        cursor: pointer;
        display: inline-block;
        font-size: 14px;
        font-weight: 500;
        line-height: 20px;
        list-style: none;
        margin: 0;
        padding: 10px 12px;
        text-align: center;
        margin: 0 0.2rem;
    }

    .distill-button:disabled {
        opacity: 0.4;
    }
    
    .distill-button:hover {
        background-color: var(--global-button-color-hover);
    }

    .punct-line .distill-button {
        color: var(--global-text-color);
    }

    .ud-button.selected-button {
        color: white;
        background-color: var(--green-color);
    }

    .opus100-button.selected-button {
        color: white;
        background-color: var(--red-color);
    }

    .ersatz-button.selected-button {
        color: white;
        background-color: var(--blue-color);
    }

    .punct-line .selected-button {
        opacity: 1;
    }

    .model {
        position: relative;
        display: inline-block;
    }

    .model-identifier {
        font-family: monospace;
        color: var(--global-theme-color);
    }

    .split::after {
        position: absolute;
        content: "";
        width: 3px;
        height: 1.3rem;
        background-color: var(--global-theme-color);
    }

    .split[data-style=ud]::after {
        background-color: var(--green-color);
    }

    .split[data-style=opus100]::after {
        background-color: var(--red-color);
    }

    .split[data-style=ersatz]::after {
        background-color: var(--blue-color);
    }

    .split:last-child::after {
        width: 0px;
    }

    .editor-container .ql-editor {
        padding: 1rem 0.5rem;        
        height: auto;
        min-height: 250px;
    }

    .editor-container .ql-editor p {
        font-family: "Roboto", sans-serif;
        font-size: 16.96px;
    }

    .editor-container .ql-editor p::after {
        position: absolute;
        width: 2px;
        height: 1.3rem;
        color:rgba(0, 0, 0, 0.2);
    }

    .editor-container .ql-container {
        height: auto;
    }

    .editor-container #quill-editor {
        height: 250px;
        overflow-y: scroll;
    }
</style>
<link href="//cdn.quilljs.com/1.0.0/quill.snow.css" rel="stylesheet" />