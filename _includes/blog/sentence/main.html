<div class="editor-container">
    <p id="quill-editor"></p>
</div>
<div class="tool-line">
    <div class="model mr-auto">Model: <span class="model-identifier">wtp-bert-tiny</span></div>
    <button class="example-button distill-button">Example Text</button>
    <button class="clear-button distill-button">Clear</button>
</div>
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<script src="https://cdn.quilljs.com/1.3.7/quill.min.js"></script>
<script>
    const Inline = Quill.import("blots/inline");

    class SplitBlot extends Inline {
        static blotName = "split";
        static tagName = "span";
        constructor(domNode, value) {
            super(domNode, value);
            if (typeof value === "object") {
                this.domNode.dataset.guid = value.guid;
            }
        }

        static create() {
            const node = super.create();
            node.classList.add("split");
            return node;
        }

        static formats(node) {
            return node.dataset.guid;
        }
    }
    Quill.register(SplitBlot);
    // see https://github.com/quilljs/quill/issues/2312#issuecomment-426221880
    Inline.order.splice(Inline.order.indexOf("bold"), 0, name);

    async function getEmbeddings(url) {
        return await fetch(url).then((response) => {
            return response.arrayBuffer();
        }).then((buffer) => {
            let view = new DataView(buffer);
            let numBuckets = view.getInt32(0, true);
            let numHashes = view.getInt32(4, true);
            let hashDim = (view.byteLength - 8) / (numBuckets * numHashes) / 4;

            let embeddings = [...Array(numHashes)].map(() => []);
            for (let i = 0; i < numBuckets; i++) {
                for (let j = 0; j < numHashes; j++) {
                    let offset = 8 + (i * numHashes + j) * hashDim * 4;
                    let data = new Float32Array(buffer, offset, hashDim);
                    embeddings[j].push(data);
                }
            }

            return embeddings;
        });
    }

    async function getModel() {
        const [embeddings, session] = await Promise.all([
            getEmbeddings("/assets/blog/sentence/embeddings.bin"),
            ort.InferenceSession.create('/assets/blog/sentence/model.onnx')
        ]);

        return {
            embeddings: embeddings,
            session: session
        };
    }

    const model = getModel();

    // use an async context to call onnxruntime functions.

    const _PRIMES = [31, 43, 59, 61, 73, 97, 103, 113, 137, 149, 157, 173, 181, 193, 211, 223];

    function embed(text, embeddings) {
        let numBuckets = embeddings[0].length;
        let numHashes = embeddings.length;
        let hashDim = embeddings[0][0].length;

        let result = new Float32Array(text.length * numHashes * hashDim);
        for (let i = 0; i < text.length; i++) {
            for (let j = 0; j < numHashes; j++) {
                let hash = ((text.charCodeAt(i) + 1) * _PRIMES[j]) % numBuckets;

                for (let k = 0; k < hashDim; k++) {
                    result[i * numHashes * hashDim + j * hashDim + k] = embeddings[j][hash][k];
                }
            }
        }

        return {
            data: result,
            dim: numHashes * hashDim
        };
    }

    function sigmoid(x) {
        return 1 / (1 + Math.exp(-x));
    }

    async function infer(text, model) {
        const emb = embed(text, (await model).embeddings);
        const tensorInputsEmbeds = new ort.Tensor('float32', emb.data, [1, text.length, emb.dim]);

        // prepare feeds. use model input names as keys.
        const feeds = { inputs_embeds: tensorInputsEmbeds };

        // feed inputs and run
        const results = await (await model).session.run(feeds);

        // read from results
        const logits = results.logits.data;
        const dim = results.logits.dims[results.logits.dims.length - 1];
        const newlineProbs = new Float32Array(text.length);

        for (let i = 0; i < text.length; i++) {
            newlineProbs[i] = sigmoid(logits[dim * i]);
        }

        return newlineProbs;
    }

    window.addEventListener("load", () => {
        const quill = new Quill("#quill-editor", {
            modules: {
                toolbar: null,
                history: {
                    userOnly: true,
                },
            },
            formats: ["split"],
        });
        quill.root.setAttribute("spellcheck", false);

        // see https://github.com/quilljs/quill/issues/110#issuecomment-461591218
        delete quill.getModule("keyboard").bindings["9"];

        function getText() {
            return Array.from(quill.container.querySelectorAll("p"))
                .map((el) => el.textContent)
                .join("\n");
        }

        let predict_timeout = null;
        let predict_delta = 300;

        async function populate(text) {
            const probs = await infer(text, model);

            if (getText() != text) {
                // split is not valid anymore
                return;
            }

            quill.formatText(0, text.length, { split: false });

            let offset = 0;
            probs[text.length - 1] = 1.0;
            for (let i = 0; i < text.length; i++) {
                if (probs[i] > 0.01) {
                    let length = i - offset + 1;
                    quill.formatText(offset, length, {
                        split: {
                            guid: `${offset}_${length}`,
                        },
                    });
                    offset = i + 1;
                }
            }
        }

        quill.on("text-change", async (delta, oldDelta, user) => {
            let text = getText();

            document.querySelector(".clear-button").disabled = text == "";
            document.querySelector(".example-button").disabled = text == example;

            if (user === "api") {
                return;
            }

            quill.formatText(0, text.length, { split: false });

            clearTimeout(predict_timeout);
            predict_timeout = setTimeout(() => {
                populate(text);
            }, predict_delta);
        });

        const example = "Click here to play around with sentence segmentation! The best segmentation is often obvious, but in some cases it's not. For example, when they said \"This is a sentence. This is another sentence\", it is not obvious whether the quote should be part of the surrounding sentence, or should itself be split into sentences.\n\nThe model is loaded on the client-side in your browser. It is fast enough to allow live-editing. Check out the Github repository to use it yourself: github.com/bminixhofer/wtpsplit.";

        document.querySelector(".example-button").addEventListener("click", () => {
            quill.setText(example, "api");
            populate(example);
            userEditing = false;
        });
        document.querySelector(".clear-button").addEventListener("click", () => {
            quill.setText("", "user");
            userEditing = false;
        });

        quill.setText(example, "api");
        populate(example);
    });
</script>

<style>
    .editor-container {
        border: 1px solid rgba(0, 0, 0, 0.2);
        border-radius: 5px;
    }

    .tool-line {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.5rem;
        margin-bottom: 2rem;
    }

    .distill-button {
        background-color: var(--global-button-color);
        border-radius: 8px;
        border-width: 0;
        cursor: pointer;
        display: inline-block;
        font-size: 14px;
        font-weight: 500;
        line-height: 20px;
        list-style: none;
        margin: 0;
        padding: 10px 12px;
        text-align: center;
        transition: all 200ms;
        margin: 0 0.2rem;
    }

    .distill-button:disabled {
        opacity: 0.8;
    }
    
    .distill-button:hover {
        background-color: var(--global-button-color-hover);
    }

    .model {
        position: relative;
        display: inline-block;
    }

    .model-identifier {
        font-family: monospace;
        color: var(--global-theme-color);
    }

    .split::after {
        position: absolute;
        content: "";
        width: 3px;
        height: 1.3rem;
        background-color: var(--global-theme-color);
    }

    .split:last-child::after {
        width: 0px;
    }

    .editor-container .ql-editor {
        padding: 1rem 0.5rem;        
        height: auto;
        min-height: 250px;
    }

    .editor-container .ql-editor p {
        font-family: "Roboto", sans-serif;
        font-size: 16.96px;
    }

    .editor-container .ql-editor p::after {
        position: absolute;
        width: 2px;
        height: 1.3rem;
        color:rgba(0, 0, 0, 0.2);
    }

    .editor-container .ql-container {
        height: auto;
    }

    .editor-container #quill-editor {
        height: 250px;
        overflow-y: scroll;
    }
</style>
<link href="//cdn.quilljs.com/1.0.0/quill.snow.css" rel="stylesheet" />